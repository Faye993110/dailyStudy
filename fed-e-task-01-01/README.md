雷代文 ｜ Part 1 | 模块一

第一题
最终执行结果为：打印出 10。

原因是因为 for 循环之后，变量i没有被销毁，变成了全局变量，导致打印出10

第二题

会报错，是因为在let声明变量前，使用该变量，它是会报错的，而不是像var那样会‘变量提升’。

第三题

const findMin = (arr) => Math.min(...arr)

第四题

使用var声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象；使用 var 在全局级别（在函数外部）进行声明都会自动成为 window 对象上的一个属性;
使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；
使用const声明的是常量，在后面出现的代码中不能再修改该常量的值。

第五题

执行结果是20
this指向调用的对象

第六题
可以阻止对象属性名冲突
模拟私有属性

第七题
深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用，
深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。

第八题
对浏览器中EventLoop的理解：
我们在浏览器中执行javaScript的代码流程可以为：
1、执行全局script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；
2、全局Script代码执行完毕后，调用栈Stack会清空；
3、从微队列中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后微队列长度减1；
4、继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把微队列中的所有任务都执行完毕。如果在执行微任务的过程中，又产生了微任务，那么会加入到微队列的末尾，也会在这个周期被调用执行；
5、微任务队列中的所有任务都执行完毕，此时微队列为空队列，调用栈Stack也为空；
6、取出宏队列中位于队首的任务，放入Stack中执行；
7、执行完毕后，调用栈Stack为空；

宏任务： 一些异步任务的回调，放到宏队列中的，例如：setTimeout/setInterval
微任务： 另一些异步任务的回调，放到微任务中的，例如：Promise
当有宏任务和微任务同时在队列中时，微任务一般来说，执行的优先级较高

第九题

function newVersion(string) {
  return new Promise(function(resolve) {
    setTimeout(function(){
      resolve(string);
    }, 10);
  });
}

(async function main() {
  let string = '';
  a = await newVersion('hello');
  b = await newVersion('lagou');
  c = await newVersion('i love u');
  console.log(a+b+c);
  }
})();

第10题

Typescript是JavaScript的一个超集，JavaScript 的语言扩展. typescript 增加了静态类型、类、模块、接口和类型注解方面的功能，实现以面向对象编程的方式使用Javascript。当然最后代码还是编译为Javascript。

第11题
优点：1、typescript 是静态类型，javascript是动态类型，typescript在编写的时候，就算没有执行，如果有错就会报出来，不需要等到执行的时候
    2、在开发大型项目的时候，有时为了改进开发项目，需要对代码库进行小的增量更改。这些小小的变化可能会产生严重的、意想不到的后果，因此有必要撤销这些变化。使用TypeScript工具来进行重构变的更容易、快捷
    3、当发开大型项目时，会有许多开发人员，此时乱码和错误的机也会增加。类型安全是一种在编码期间检测错误的功能，而不是在编译项目时检测错误。这为开发团队创建了一个更高效的编码和调试过程。会减少人为的bug
    4、TypeScript 引入了 JavaScript 中没有的“类”概念。TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。
缺点： 1、TypeScript 代码需要被编译（输出 JavaScript 代码），这是 TypeScript 代码执行时的一个额外的步骤。
      2、需要一个学习成本在里面
      3、不如js灵活

